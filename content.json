{"meta":{"title":"Hexo","subtitle":"","description":"","author":"Shen Haojie","url":"http://zakiman.github.io","root":"/"},"pages":[],"posts":[{"title":"proxy","slug":"proxy","date":"2020-10-13T15:24:28.166Z","updated":"2020-10-13T15:27:48.762Z","comments":true,"path":"2020/10/13/proxy/","link":"","permalink":"http://zakiman.github.io/2020/10/13/proxy/","excerpt":"","text":"跨域的方法有哪些？原理是什么？知其然知其所以然，在说跨域方法之前，我们先了解下什么叫跨域，浏览器有同源策略，只有当“协议”、“域名”、“端口号”都相同时，才能称之为是同源，其中有一个不同，即是跨域。 那么同源策略的作用是什么呢？同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。 那么我们又为什么需要跨域呢？一是前端和服务器分开部署，接口请求需要跨域，二是我们可能会加载其它网站的页面作为 iframe 内嵌。 常用的跨域方法： jsonp尽管浏览器有同源策略，但是 标签的 src 属性不会被同源策略所约束，可以获取任意服务器上的脚本并执行。jsonp 通过插入 script 标签的方式来实现跨域，参数只能通过 url 传入，仅能支持 get 请求。 实现原理: Step1: 创建 callback 方法 Step2: 插入 script 标签 Step3: 后台接受到请求，解析前端传过去的 callback 方法，返回该方法的调用，并且数据作为参数传入该方法 Step4: 前端执行服务端返回的方法调用 下面代码仅为说明 jsonp 原理，项目中请使用成熟的库。分别看一下前端和服务端的简单实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//前端代码function jsonp(&#123; url, params, cb &#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; //创建 script 标签 let script = document.createElement('script') //将回调函数挂在 window 上 window[cb] = function (data) &#123; resolve(data) //代码执行后，删除插入的 script 标签 document.body.removeChild(script) &#125; //回调函数加在请求地址上 params = &#123; ...params, cb &#125; //wb=b&amp;cb=show let arrs = [] for (let key in params) &#123; arrs.push(`$&#123;key&#125;=$&#123;params[key]&#125;`) &#125; script.src = `$&#123;url&#125;?$&#123;arrs.join('&amp;')&#125;` document.body.appendChild(script) &#125;)&#125;//使用function sayHi(data) &#123; console.log(data)&#125;jsonp(&#123; url: 'http://localhost:3000/say', params: &#123; //code &#125;, cb: 'sayHi',&#125;).then((data) =&gt; &#123; console.log(data)&#125;)/* ------------------------ *///express 启动一个后台服务let express = require('express')let app = express()app.get('/say', (req, res) =&gt; &#123; let &#123; cb &#125; = req.query //获取传来的 callback 函数名，cb 是 key res.send(`$&#123;cb&#125;('Hello!')`)&#125;)app.listen(3000) 从今天起，jsonp 的原理就要了然于心啦~ corsjsonp 只能支持 get 请求，cors 可以支持多种请求。cors 并不需要前端做什么工作。 简单跨域请求: 只要服务器设置的 Access-Control-Allow-Origin Header 和请求来源匹配，浏览器就允许跨域 请求的方法是 get，head 或者 post。Content-Type 是 application/x-www-form-urlencoded, multipart/form-data 或 text/plain 中的一个值，或者不设置也可以，一般默认就是 application/x-www-form-urlencoded。请求中没有自定义的 HTTP 头部，如 x-token。(应该是这几种头部 Accept，Accept-Language，Content-Language，Last-Event-ID，Content-Type） 1234//简单跨域请求app.use((req, res, next) =&gt; &#123; res.setHeader('Access-Control-Allow-Origin', 'XXXX')&#125;) 带预检(Preflighted)的跨域请求 不满于简单跨域请求的，即是带预检的跨域请求。服务端需要设置 Access-Control-Allow-Origin (允许跨域资源请求的域) 、 Access-Control-Allow-Methods (允许的请求方法) 和 Access-Control-Allow-Headers (允许的请求头) 123456789app.use((req, res, next) =&gt; &#123; res.setHeader('Access-Control-Allow-Origin', 'XXX') res.setHeader('Access-Control-Allow-Headers', 'XXX') //允许返回的头 res.setHeader('Access-Control-Allow-Methods', 'XXX') //允许使用 put 方法请求接口 res.setHeader('Access-Control-Max-Age', 6) //预检的存活时间 if (req.method === 'OPTIONS') &#123; res.end() //如果 method 是 OPTIONS，不做处理 &#125;&#125;) nginx 反向代理使用 nginx 反向代理实现跨域，只需要修改 nginx 的配置即可解决跨域问题。 A 网站向 B 网站请求某个接口时，向 B 网站发送一个请求，nginx 根据配置文件接收这个请求，代替 A 网站向 B 网站来请求。nginx 拿到这个资源后再返回给 A 网站，以此来解决了跨域问题。 例如 nginx 的端口号为 8090，需要请求的服务器端口号为 3000。（localhost:8090 请求 localhost:3000/say） nginx 配置如下: 12345678910111213141516171819server &#123;listen 8090; server_name localhost; location &#x2F; &#123; root &#x2F;Users&#x2F;liuyan35&#x2F;Test&#x2F;Study&#x2F;CORS&#x2F;1-jsonp; index index.html index.htm; &#125; location &#x2F;say &#123; rewrite ^&#x2F;say&#x2F;(.*)$ &#x2F;$1 break; proxy_pass http:&#x2F;&#x2F;localhost:3000; add_header &#39;Access-Control-Allow-Origin&#39; &#39;*&#39;; add_header &#39;Access-Control-Allow-Credentials&#39; &#39;true&#39;; add_header &#39;Access-Control-Allow-Methods&#39; &#39;GET, POST, OPTIONS&#39;; &#125; # others&#125; websocketWebsocket 是 HTML5 的一个持久化的协议，它实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方案。 Websocket 不受同源策略影响，只要服务器端支持，无需任何配置就支持跨域。 前端页面在 8080 的端口。 1234567891011121314151617let socket = new WebSocket('ws://localhost:3000'); //协议是 wssocket.onopen = function() &#123;socket.send('Hi,你好');&#125;socket.onmessage = function(e) &#123;console.log(e.data)&#125;服务端 3000 端口。可以看出 websocket 无需做跨域配置。let WebSocket = require('ws');let wss = new WebSocket.Server(&#123;port: 3000&#125;);wss.on('connection', function(ws) &#123;ws.on('message', function(data) &#123;console.log(data); //接受到页面发来的消息'Hi,你好'ws.send('Hi'); //向页面发送消息&#125;);&#125;); postMessagepostMessage 通过用作前端页面之前的跨域，如父页面与 iframe 页面的跨域。window.postMessage 方法，允许跨窗口通信，不论这两个窗口是否同源。 话说工作中两个页面之前需要通信的情况并不多，我本人工作中，仅使用过两次，一次是 H5 页面中发送 postMessage 信息，ReactNative 的 webview 中接收此此消息，并作出相应处理。另一次是可轮播的页面，某个轮播页使用的是 iframe 页面，为了解决滑动的事件冲突，iframe 页面中去监听手势，发送消息告诉父页面是否左滑和右滑。 子页面向父页面发消息 父页面 1234567window.addEventListener( 'message', (e) =&gt; &#123; this.props.movePage(e.data) &#125;, false) 子页面(iframe): 12345if(/*左滑*/) &#123;window.parent &amp;&amp; window.parent.postMessage(-1, '*')&#125;else if(/*右滑*/)&#123;window.parent &amp;&amp; window.parent.postMessage(1, '*')&#125; 父页面向子页面发消息 父页面: 1234let iframe = document.querySelector('#iframe')iframe.onload = function () &#123; iframe.contentWindow.postMessage('hello', 'http://localhost:3002')&#125; 子页面: 1234window.addEventListener('message', function (e) &#123; console.log(e.data) e.source.postMessage('Hi', e.origin) //回消息&#125;) node 中间件node 中间件的跨域原理和 nginx 代理跨域，同源策略是浏览器的限制，服务端没有同源策略。 node 中间件实现跨域的原理如下: 1.接受客户端请求 2.将请求 转发给服务器。 3.拿到服务器 响应 数据。 4.将 响应 转发给客户端。","categories":[],"tags":[]},{"title":"event-loop","slug":"eventLoop","date":"2020-10-13T15:23:54.940Z","updated":"2020-10-13T15:28:49.355Z","comments":true,"path":"2020/10/13/eventLoop/","link":"","permalink":"http://zakiman.github.io/2020/10/13/eventLoop/","excerpt":"","text":"Event Loop 是一个很重要的概念，指的是计算机系统的一种运行机制。 浏览器 或 Node 对于 javascript 语言就采用这种机制，来解决单线程运行带来的一些问题。 the event loop is a programming construct or design pattern that waits for and dispatches events or messages in a program.参考维基 堆，栈、队列堆（Heap）堆是一种数据结构，是利用完全二叉树维护的一组数据，堆分为两种，一种为最大堆，一种为最小堆，将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。 堆是线性数据结构，相当于一维数组，有唯一后继。 栈（Stack）栈在计算机科学中是限定仅在表尾进行插入或删除操作的线性表。栈是一种数据结构，它按照后进先出的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据。 栈是只能在某一端插入和删除的特殊线性表。 队列（Queue）特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。 进行插入操作的端称为队尾，进行删除操作的端称为队头。 队列中没有元素时，称为空队列。 队列的数据元素又称为队列元素。在队列中插入一个队列元素称为入队，从队列中删除一个队列元素称为出队。因为队列只允许在一端插入，在另一端删除，所以只有最早进入队列的元素才能最先从队列中删除，故队列又称为先进先出（FIFO—first in first out） 任务（Task）在 JavaScript 中，任务被分为两种，一种宏任务（MacroTask）也叫 Task，一种叫微任务（MicroTask）。 MacroTask（宏任务） script 全部代码 setTimeout、setInterval、setImmediate（浏览器暂时不支持，只有 IE10 支持，具体可见 MDN） I/O UI Rendering MicroTask（微任务） Process.nextTick（Node 独有） Promise Object.observe(废弃) MutationObserver 事件循环的进程模型执行栈在执行完同步任务后，查看执行栈是否为空，如果执行栈为空，就会去执行 Task（宏任务），每次宏任务执行完毕后，检查微任务(microTask)队列是否为空，如果不为空的话，会按照先入先出的规则全部执行完微任务(microTask)后，设置微任务(microTask)队列为 null，然后再执行宏任务，如此循环。 选择当前要执行的任务队列，选择任务队列中最先进入的任务，如果任务队列为空即 null，则执行跳转到微任务（MicroTask）的执行步骤。 将事件循环中的任务设置为已选择任务。 执行任务。 将事件循环中当前运行任务设置为 null。 将已经运行完成的任务从任务队列中删除。 microtasks 步骤：进入 microtask 检查点。 更新界面渲染。 返回第一步 执行进入 microtask 检查点时，用户代理会执行以下步骤： 设置 microtask 检查点标志为 true。 当事件循环 microtask 执行不为空时：选择一个最先进入的 microtask 队列的 microtask，将事件循环的 microtask 设置为已选择的 microtask，运行 microtask，将已经执行完成的 microtask 为 null，移出 microtask 中的 microtask。 清理 IndexDB 事务 设置进入 microtask 检查点的标志为 false。","categories":[],"tags":[]},{"title":"data-type","slug":"dataType","date":"2020-10-13T15:23:34.469Z","updated":"2020-10-13T15:30:48.113Z","comments":true,"path":"2020/10/13/dataType/","link":"","permalink":"http://zakiman.github.io/2020/10/13/dataType/","excerpt":"","text":"学习一门语言，首要掌握它的字符串及数组操作方法，下面是整理的数据类型知识汇总： 如何判断数据类型 typeof 用以判断基本数据类型，其中 typeof null 返回 object，但是 null 不是对象。 instanceof 是通过原型链判断的，A instanceof B，在 A 的原型链中层层查找，是否有原型等于 B.prototype，如果找到顶端（null）仍未找到，那么返回 false，否则返回 true。 instanceof 的实现代码： 1234567891011121314// L instanceof Rfunction instance_of(L, R) &#123; var O = R.prototype // 取R的显式原型 L = L.__proto__ // 取L的隐式原型 while (true) &#123; if (L === null) &#123; return false // 找到顶层 &#125; if (O === L) &#123; return true // 全等即找到 &#125; L = L.__proto__ // 继续向上查找 &#125;&#125; 字符串 数组如何判断一个数组？ 使用 Array.isArray 判断，如果返回 true，说明是数组 使用 instanceof Array 判断，如果返回 true，说明是数组 使用 Object.prototype.toString.call 判断，如果返回 [Object Array]，说明是数组 类数组和数组的区别？类数组是一个拥有 length 属性的普通对象，并非 Array 类型，不具备数组的方法。转换数组方法： 123Array.prototype.slice.call(arrayLike, start);[...arrayLike]Array.from(arrayLike) 数组的哪些 API 会改变原数组？ 修&emsp;改：splice/reverse/fill/copyWithin/sort/push/pop/unshift/shift 不修改：slice/map/forEach/every/filter/reduce/entries/find","categories":[],"tags":[]}],"categories":[],"tags":[]}